<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: routes/claims.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: routes/claims.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview This file defines the routes for handling claims in the Budget Claims System.
 * It includes routes for exporting claims as PDF, adding new claims, searching for claims,
 * fetching all claims, and updating existing claims. The routes are protected by authentication
 * and role-based access control middleware.
 * 
 * @requires express
 * @requires ../models/Claim
 * @requires path
 * @requires ../middleware/auth
 * @requires ../middleware/activityLogger
 * @requires ../notifications/notify
 * @requires csv-express
 * @requires exceljs
 * @requires pdfkit
 * @requires fs
 * @requires cache-manager
 * @requires cache-manager-redis-store
 * @requires ../logger
 * @requires ../models/Status
 * @requires ../models/Location
 * @requires ../models/DamageType
 */

const express = require('express'); // Import Express to create a router
const Claim = require('../models/Claim'); // Import the Claim model to interact with the claims collection in MongoDB
const path = require('path'); // Import Path to handle file and directory paths
const { ensureAuthenticated, ensureRoles, ensureRole } = require('../middleware/auth'); // Import authentication and role-checking middleware
const logActivity = require('../middleware/activityLogger'); // Import activity logging middleware
const { notifyNewClaim, notifyClaimStatusUpdate, notifyClaimAssigned, notifyClaimUpdated } = require('../notifications/notify'); // Import notification functions
const csv = require('csv-express'); // Import csv-express for CSV export
const ExcelJS = require('exceljs'); // Import ExcelJS for Excel export
const PDFDocument = require('pdfkit'); // Import PDFKit for PDF export
const fs = require('fs'); // Import File System to handle file operations
const cacheManager = require('cache-manager'); // Import cache manager for caching
const redisStore = require('cache-manager-redis-store'); // Import Redis store for cache manager
const pinoLogger = require('../logger'); // Import Pino logger
const Status = require('../models/Status'); // Import Status model
const Location = require('../models/Location'); // Import Location model
const DamageType = require('../models/DamageType'); // Import DamageType model
const fileUpload = require('express-fileupload');
const Settings = require('../models/Settings'); // Import Settings model
const uploadsPath = require('../config/settings');
const logRequest = require('../middleware/auditLogger');
const logger = require('../logger');

// Setup cache manager with Redis
const cache = cacheManager.caching({
    store: redisStore,
    host: process.env.REDIS_HOST || '127.0.0.1',
    port: process.env.REDIS_PORT || 6379,
    ttl: 600 // Time-to-live for cached data (in seconds)
});

// Helper function to validate file
const validateFile = (file, category) => {
    const ext = path.extname(file.name).toLowerCase();
    const allowedTypes = category === 'photos' ? global.ALLOWED_FILE_TYPES.photos :
                        category === 'invoices' ? global.ALLOWED_FILE_TYPES.invoices :
                        global.ALLOWED_FILE_TYPES.documents;

    const sizeLimit = category === 'photos' ? global.MAX_FILE_SIZES.photos :
                     category === 'invoices' ? global.MAX_FILE_SIZES.invoices :
                     global.MAX_FILE_SIZES.documents;

    const errors = [];

    // Check file type with more user-friendly message
    if (!allowedTypes.includes(ext)) {
        errors.push(`${file.name}: File type not allowed. Please use ${allowedTypes.join(', ')} for ${category}`);
    }

    // Check file size with more user-friendly message
    if (file.size > sizeLimit) {
        const sizeMB = Math.round(sizeLimit / (1024 * 1024));
        errors.push(`${file.name}: File is too large. Maximum size allowed is ${sizeMB}MB`);
    }

    // Check file name with more user-friendly message
    if (file.name.length > 100 || /[&lt;>:"/\\|?*]/.test(file.name)) {
        errors.push(`${file.name}: File name is invalid. Please remove special characters and ensure name is less than 100 characters`);
    }

    return errors;
};

// Helper function to sanitize filename
const sanitizeFilename = (filename) => {
    return filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase();
};

const router = express.Router(); // Create a new router

// Define sensitive fields that should not be logged
const sensitiveFields = ['password', 'token', 'ssn'];

// Function to filter out sensitive fields from the request body
const filterSensitiveData = (data) => {
    const filtered = { ...data };
    const sensitiveFields = ['password', 'token', 'ssn', 'creditCard'];
    
    sensitiveFields.forEach(field => {
        if (filtered[field]) {
            filtered[field] = '[REDACTED]';
        }
    });
    
    return filtered;
};

// Helper function to initialize file categories
const initializeFileCategories = (existingFiles = {}) => {
    const categories = ['photos', 'documents', 'invoices'];
    const files = { ...existingFiles };
    
    categories.forEach(category => {
        if (!files[category]) {
            files[category] = [];
        }
    });
    
    return files;
};

// Route to export a claim as PDF
router.get('/:id/export', ensureAuthenticated, ensureRoles(['admin', 'manager', 'employee']), async (req, res) => {
    const claimId = req.params.id;
    logRequest(req, `Exporting claim to PDF with ID: ${claimId}`);

    try {
        const claim = await Claim.findById(claimId)
            .populate('status')
            .populate('rentingLocation')
            .populate('damageType');

        if (!claim) {
            logRequest(req, `Claim with ID ${claimId} not found`, { level: 'error' });
            return res.status(404).render('404', { message: 'Claim not found' });
        }

        const doc = new PDFDocument({ autoFirstPage: true, margin: 50 });
        const filename = `claim_${claimId}.pdf`;
        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);
        res.setHeader('Content-Type', 'application/pdf');

        doc.pipe(res);

        // Helper function to add a field to the PDF
        const addField = (label, value) => {
            let displayValue = value;
            if (value === undefined || value === null || value === '') {
                displayValue = 'Not Provided';
            } else if (typeof value === 'boolean') {
                displayValue = value ? 'Yes' : 'No';
            }
            doc.text(`${label}: ${displayValue}`, { continued: false });
            doc.moveDown(0.5);
        };

        // Helper function to add a section header
        const addSectionHeader = (title) => {
            doc.moveDown();
            doc.fontSize(16).text(title, { underline: true });
            doc.moveDown();
            doc.fontSize(12);
        };

        // Title Page
        doc.fontSize(24).text('Claim Report', { align: 'center' });
        doc.moveDown();
        doc.fontSize(16).text(`Claim #${claim.claimNumber}`, { align: 'center' });
        doc.moveDown();
        doc.text(`Generated on: ${new Date().toLocaleString()}`, { align: 'center' });
        doc.moveDown(2);

        // Table of Contents
        doc.fontSize(14).text('Table of Contents', { underline: true });
        doc.moveDown();
        doc.fontSize(12);
        const sections = [
            'Claim Overview',
            'Customer Information',
            'Vehicle Information',
            'Accident Details',
            'Insurance Information',
            'Third Party Information',
            'Financial Information',
            'Notes and Comments',
            'Attached Documents'
        ];
        sections.forEach((section, index) => {
            doc.text(`${index + 1}. ${section}`);
            doc.moveDown(0.5);
        });

        // Claim Overview
        doc.addPage();
        addSectionHeader('1. Claim Overview');
        addField('Claim Number', claim.claimNumber);
        addField('MVA', claim.mva);
        addField('Status', claim.status ? claim.status.name : 'Not Set');
        addField('Date Created', new Date(claim.date).toLocaleDateString());
        addField('Claim Close Date', claim.claimCloseDate ? new Date(claim.claimCloseDate).toLocaleDateString() : 'Not Closed');
        addField('Description', claim.description);

        // Customer Information
        doc.addPage();
        addSectionHeader('2. Customer Information');
        addField('Customer Name', claim.customerName);
        addField('Customer Number', claim.customerNumber);
        addField('Customer Email', claim.customerEmail);
        addField('Customer Phone', claim.customerPhone);
        addField('Customer Address', claim.customerAddress);
        addField('Customer Drivers License', claim.customerDriversLicense);

        // Vehicle Information
        doc.addPage();
        addSectionHeader('3. Vehicle Information');
        addField('Car Make', claim.carMake);
        addField('Car Model', claim.carModel);
        addField('Car Year', claim.carYear);
        addField('Car Color', claim.carColor);
        addField('Car VIN', claim.carVIN);
        addField('Vehicle Odometer', claim.vehicleOdometer);
        addField('RA Number', claim.raNumber);
        addField('Renting Location', claim.rentingLocation ? claim.rentingLocation.name : 'Not Specified');

        // Accident Details
        doc.addPage();
        addSectionHeader('4. Accident Details');
        addField('Accident Date', claim.accidentDate ? new Date(claim.accidentDate).toLocaleDateString() : 'Not Specified');
        addField('Damage Type', claim.damageType ? claim.damageType.name : 'Not Specified');
        addField('Police Department', claim.policeDepartment);
        addField('Police Report Number', claim.policeReportNumber);
        addField('Is Renter At Fault', claim.isRenterAtFault);
        addField('Body Shop Name', claim.bodyShopName);
        addField('Description of Damage', claim.description);

        // Insurance Information
        doc.addPage();
        addSectionHeader('5. Insurance Information');
        addField('Insurance Carrier', claim.insuranceCarrier);
        addField('Insurance Agent', claim.insuranceAgent);
        addField('Insurance Phone Number', claim.insurancePhoneNumber);
        addField('Insurance Fax Number', claim.insuranceFaxNumber);
        addField('Insurance Address', claim.insuranceAddress);
        addField('Insurance Claim Number', claim.insuranceClaimNumber);
        addField('Renters Liability Insurance', claim.rentersLiabilityInsurance);
        addField('Loss Damage Waiver', claim.lossDamageWaiver);
        addField('LDW Accepted', claim.ldwAccepted);

        // Third Party Information
        doc.addPage();
        addSectionHeader('6. Third Party Information');
        addField('Third Party Name', claim.thirdPartyName);
        addField('Third Party Phone Number', claim.thirdPartyPhoneNumber);
        addField('Third Party Insurance Name', claim.thirdPartyInsuranceName);
        addField('Third Party Policy Number', claim.thirdPartyPolicyNumber);

        // Financial Information
        doc.addPage();
        addSectionHeader('7. Financial Information');
        addField('Billable', claim.billable);
        addField('Damages Total', claim.damagesTotal ? `$${claim.damagesTotal}` : 'Not Specified');
        if (claim.invoiceTotals &amp;&amp; claim.invoiceTotals.length > 0) {
            doc.moveDown();
            doc.text('Invoice Totals:', { underline: true });
            claim.invoiceTotals.forEach(invoice => {
                doc.text(`- ${invoice.fileName}: $${invoice.total}`);
            });
        }

        // Notes and Comments
        doc.addPage();
        addSectionHeader('8. Notes and Comments');
        if (claim.notes &amp;&amp; claim.notes.length > 0) {
            claim.notes.forEach((note, index) => {
                doc.text(`Note ${index + 1}:`);
                doc.text(`Date: ${new Date(note.createdAt).toLocaleString()}`);
                doc.text(`Type: ${note.type}`);
                doc.text(`Content: ${note.content}`);
                doc.moveDown();
            });
        } else {
            doc.text('No notes available');
        }

        // Attached Documents
        doc.addPage();
        addSectionHeader('9. Attached Documents');
        const files = claim.files || {};
        const fileCategories = [
            { title: 'Photos', files: files.photos || [] },
            { title: 'Documents', files: files.documents || [] },
            { title: 'Invoices', files: files.invoices || [] },
            { title: 'Police Reports', files: files.policeReports || [] },
            { title: 'Rental Agreements', files: files.rentalAgreements || [] }
        ];

        fileCategories.forEach(category => {
            if (category.files.length > 0) {
                doc.moveDown();
                doc.fontSize(16).text(category.title, { underline: true });
                doc.fontSize(12);
                
                category.files.forEach((file, index) => {
                    const filePath = path.join(__dirname, '../public/uploads', file);
                    try {
                        if (file.match(/\.(png|jpg|jpeg)$/i)) {
                            // Start a new page for each image
                            if (index > 0) {
                                doc.addPage();
                            }
                            
                            // Add image title
                            doc.fontSize(14).text(file, { align: 'center' });
                            doc.moveDown();
                            
                            // Add image with consistent sizing
                            doc.image(filePath, {
                                fit: [500, 600],
                                align: 'center'
                            });
                            
                            // Add page number for photos
                            doc.fontSize(10)
                                .text(
                                    `Photo ${index + 1} of ${category.files.length}`,
                                    { align: 'center' }
                                );

                            // Add a new page after the last photo in the category
                            if (index === category.files.length - 1) {
                                doc.addPage();
                            }
                        } else {
                            // For non-image files
                            doc.fontSize(12).text(`- ${file}`);
                            doc.moveDown(0.5);
                        }
                    } catch (error) {
                        doc.fontSize(12).text(`Error processing file: ${file}`);
                        logRequest(req, 'Error processing file:', { error, file });
                        doc.moveDown();
                    }
                });
            } else {
                doc.moveDown();
                doc.fontSize(14).text(`${category.title}: No files attached`);
                doc.fontSize(12);
            }
            doc.moveDown(2);
        });

        doc.end();

    } catch (err) {
        logRequest(req, 'Error exporting claim to PDF:', { error: err });
        res.status(500).render('500', { message: 'Internal Server Error' });
    }
});

// Route to display the add claim form
router.get('/add', ensureAuthenticated, ensureRoles(['admin', 'manager', 'employee']), async (req, res) => {
    try {
        const statuses = await Status.find().sort({ name: 1 });
        const locations = await Location.find().sort({ name: 1 });
        const damageTypes = await DamageType.find().sort({ name: 1 });
        const claim = {
            invoice: '',
            amount: ''
        };

        logRequest(req, 'Add claim route accessed');

        res.render('add_claim', {
            title: 'Add Claim',
            statuses,
            locations,
            damageTypes,
            claim,
            nonce: res.locals.nonce
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// Route to display the express claim form
router.get('/express', ensureAuthenticated, ensureRoles(['admin', 'manager', 'employee']), async (req, res) => {
    try {
        logRequest(req, 'Express claim route accessed');
        res.render('express_claim', {
            title: 'Express Claim',
            nonce: res.locals.nonce
        });
    } catch (error) {
        logRequest(req, 'Error accessing express claim form:', { error });
        res.status(500).render('500', { message: 'Internal Server Error' });
    }
});

// Route to search for claims, accessible by admin, manager, and employee
router.get('/search', ensureAuthenticated, ensureRoles(['admin', 'manager', 'employee']), async (req, res) => {
    try {
        // Fetch necessary data for the search form
        const damageTypes = await DamageType.find().sort({ name: 1 });
        const statuses = await Status.find().sort({ name: 1 });
        const locations = await Location.find().sort({ name: 1 });

        // Extract query parameters
        const { mva, customerName, vin, claimNumber, damageType, status, raNumber, dateOfLossStart, dateOfLossEnd, startDate, endDate } = req.query;

        // Build a filter object based on provided query parameters
        let filter = {};
        if (mva) filter.mva = mva;
        if (customerName) filter.customerName = new RegExp(customerName, 'i'); // Case-insensitive search
        if (vin) filter.carVIN = new RegExp(vin, 'i'); // Case-insensitive search for VIN
        if (claimNumber) filter.claimNumber = new RegExp(claimNumber, 'i'); // Case-insensitive search for claim number
        if (damageType) filter.damageType = { $in: Array.isArray(damageType) ? damageType : [damageType] }; // Search for any of the selected damage types
        if (status) {
            // Handle single status ID
            filter.status = status; // No need for $in since status should be a single value
        }
        if (raNumber) filter.raNumber = raNumber;
        if (dateOfLossStart || dateOfLossEnd) {
            filter.dateOfLoss = {};
            if (dateOfLossStart) filter.dateOfLoss.$gte = new Date(dateOfLossStart); // Filter by start date of loss
            if (dateOfLossEnd) filter.dateOfLoss.$lte = new Date(dateOfLossEnd); // Filter by end date of loss
        }
        if (startDate || endDate) {
            filter.date = {};
            if (startDate) filter.date.$gte = new Date(startDate); // Filter by start date
            if (endDate) filter.date.$lte = new Date(endDate); // Filter by end date
        }

        // Add debug logging for statuses
        const allStatuses = await Status.find().sort({ name: 1 });
        console.log('Available statuses:', allStatuses.map(s => ({ id: s._id, name: s.name })));

        // Get pagination parameters and fetch claims
        const page = parseInt(req.query.page) || 1;
        const resultsPerPage = parseInt(req.query.resultsPerPage) || 10;
        const skip = (page - 1) * resultsPerPage;

        const totalClaims = await Claim.countDocuments(filter);
        const totalPages = Math.ceil(totalClaims / resultsPerPage);

        const claims = await Claim.find(filter)
            .populate('status')
            .skip(skip)
            .limit(resultsPerPage)
            .lean();

        // Process claims status
        claims.forEach(claim => {
            if (Array.isArray(claim.status)) {
                const statusName = claim.status[0];
                const matchingStatus = allStatuses.find(s => s.name === statusName);
                if (matchingStatus) {
                    claim.status = { _id: matchingStatus._id, name: matchingStatus.name };
                } else {
                    claim.status = { name: statusName };
                }
            }
        });

        // Build query string
        const queryString = Object.entries(req.query)
            .filter(([key]) => !['page', 'resultsPerPage'].includes(key))
            .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
            .join('&amp;');

        // Check if this is an AJAX request
        if (req.xhr || req.headers.accept.includes('application/json')) {
            return res.json({
                claims,
                page,
                totalPages,
                totalClaims,
                resultsPerPage,
                queryString: queryString ? `&amp;${queryString}` : ''
            });
        }

        // Regular HTML response
        res.render('claims_search', {
            claims,
            filter,
            damageTypes,
            statuses: allStatuses,
            locations,
            resultsPerPage,
            page,
            totalPages,
            totalClaims,
            queryString: queryString ? `&amp;${queryString}` : ''
        });
    } catch (err) {
        console.error('Search route error:', err);
        if (req.xhr || req.headers.accept.includes('application/json')) {
            return res.status(500).json({ error: err.message });
        }
        res.status(500).render('500', { message: 'Error processing search' });
    }
});


// Route to get all claims or filter claims based on query parameters, accessible by admin, manager, and employee
router.get('/', ensureAuthenticated, logActivity('view claims'), async (req, res) => {
    try {
        let query = {};
        if (req.query.status) {
            query.status = req.query.status;
        }
        const claims = await Claim.find(query).sort({ createdAt: -1 });
        res.json(claims);
    } catch (error) {
        logger.error('Error fetching claims:', error);
        res.render('500', { message: 'Error fetching claims' });
    }
});

// POST /claims - Add a new claim
router.post('/', ensureAuthenticated, logActivity('create claim'), async (req, res) => {
    try {
        // Log the incoming request data (excluding sensitive info)
        logger.info('Creating new claim with data:', {
            ...req.body,
            // Exclude any sensitive fields if present
            customerDriversLicense: req.body.customerDriversLicense ? '[REDACTED]' : undefined,
            // Add other sensitive fields to redact as needed
        });

        // Create new claim without specifying claim number
        const newClaim = new Claim({
            ...req.body,
            createdBy: req.user._id
        });
        
        // Save the claim (claim number will be generated automatically)
        try {
            await newClaim.save();
            logger.info('New claim created successfully:', { 
                claimId: newClaim._id,
                claimNumber: newClaim.claimNumber
            });
        } catch (saveError) {
            logger.error('Error saving new claim:', {
                error: saveError.message,
                stack: saveError.stack,
                validationErrors: saveError.errors
            });
            throw saveError; // Re-throw to be caught by outer try-catch
        }
        
        // Send notification
        try {
            await notifyNewClaim(req.user.email, newClaim);
        } catch (notifyError) {
            // Log notification error but don't fail the request
            logger.error('Error sending claim notification:', {
                error: notifyError.message,
                claimId: newClaim._id
            });
        }

        // If this is an API request, send JSON response
        if (req.xhr || req.headers.accept.includes('application/json')) {
            res.status(201).json({
                success: true,
                claim: {
                    id: newClaim._id,
                    claimNumber: newClaim.claimNumber
                }
            });
        } else {
            // Otherwise redirect to the claim view page
            res.redirect(`/claims/${newClaim._id}`);
        }
    } catch (error) {
        logger.error('Error in claim creation:', {
            error: error.message,
            stack: error.stack,
            body: req.body
        });

        // If this is an API request, send JSON error response
        if (req.xhr || req.headers.accept.includes('application/json')) {
            res.status(500).json({
                success: false,
                error: process.env.NODE_ENV === 'development' ? error.message : 'Error creating claim',
                details: process.env.NODE_ENV === 'development' ? error.stack : undefined
            });
        } else {
            // For regular form submissions, render error page
            res.status(500).render('500', {
                message: 'Error creating claim',
                error: process.env.NODE_ENV === 'development' ? error.message : undefined,
                stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
            });
        }
    }
});

// Route to add a new location
router.post('/locations', ensureAuthenticated, ensureRoles(['admin', 'manager']), async (req, res) => {
    try {
        const { location } = req.body;
        const newLocation = new Location({ name: location });
        await newLocation.save();
        res.status(201).json({ message: 'Location added successfully' });
    } catch (error) {
        res.render('500', { message: 'Error adding location' });
    }
});

// Route to get a specific claim by ID for editing, accessible by admin and manager
router.get('/:id/edit', ensureAuthenticated, ensureRoles(['admin', 'manager']), logActivity('Viewed claim edit form'), async (req, res) => {
    const claimId = req.params.id;
    logRequest(req, `Fetching claim for editing with ID: ${claimId}`);

    try {
        const claim = await Claim.findById(claimId);
        if (!claim) {
            return res.status(404).render('404', { message: 'Claim not found' });
        }

        const statuses = await Status.find().sort({ name: 1 });
        const locations = await Location.find().sort({ name: 1 });
        const damageTypes = await DamageType.find().sort({ name: 1 });

        res.render('claims_edit', {
            claim,
            statuses,
            locations,
            damageTypes,
            rentingLocations: locations,
            errors: {}
        });
    } catch (err) {
        logRequest(req, 'Error fetching claim for editing:', { error: err });
        res.status(500).render('500', { message: 'Internal Server Error' });
    }
});

        
// PUT /claims/:id - Update a claim
router.put('/:id', ensureAuthenticated, logActivity('update claim'), async (req, res) => {
    try {
        const claimId = req.params.id;
        console.log('Incoming request body:', req.body);

        const claim = await Claim.findById(claimId);
        
        if (!claim) {
            logger.error('Claim not found:', claimId);
            return res.render('500', { message: 'Claim not found' });
        }

        const updateData = { 
            ...req.body,
            updatedAt: new Date() // Explicitly set updatedAt to current time
        };
        let notes = [];

        // Process existing notes
        if (claim.notes &amp;&amp; claim.notes.length > 0) {
            const deletedNotes = updateData.deletedNotes ? JSON.parse(updateData.deletedNotes) : [];
            notes = claim.notes.filter(note => !deletedNotes.includes(note._id.toString()));
        }

        // Process new note
        if (updateData.newNote) {
            try {
                let newNote;
                if (typeof updateData.newNote === 'string') {
                    newNote = JSON.parse(updateData.newNote);
                } else {
                    newNote = updateData.newNote;
                }

                if (newNote &amp;&amp; newNote.content) {
                    notes.push({
                        content: newNote.content,
                        type: newNote.type || 'user',
                        source: newNote.source || null,
                        createdAt: new Date(), // Use current time for new note
                        createdBy: req.user ? req.user._id : null
                    });
                }
            } catch (e) {
                console.error('Error parsing new note:', e);
            }
        }

        // Update the notes in the updateData
        updateData.notes = notes;

        // Remove the note fields from updateData
        delete updateData.newNote;
        delete updateData.newNotes;
        delete updateData['newNotes[]'];
        delete updateData.deletedNotes;

        // Update the claim with timestamps option
        const updatedClaim = await Claim.findByIdAndUpdate(
            claimId,
            updateData,
            { 
                new: true,
                timestamps: true // Ensure timestamps are updated
            }
        );

        // Log the update
        logger.info('Claim updated:', {
            claimId: updatedClaim._id,
            updatedAt: updatedClaim.updatedAt,
            status: updatedClaim.status
        });

        await notifyClaimStatusUpdate(req.user.email, updatedClaim);
        
        // Redirect back to the claim view
        res.redirect(`/claims/${updatedClaim._id}`);

    } catch (error) {
        logger.error('Error updating claim:', error);
        res.render('500', { 
            message: 'Error updating claim: ' + (error.message || 'Unknown error') 
        });
    }
});


// DELETE /claims/:id - Delete a claim
router.delete('/:id', ensureAuthenticated, logActivity('delete claim'), async (req, res) => {
    try {
        const claim = await Claim.findById(req.params.id);
        if (!claim) {
            return res.status(404).json({ error: 'Claim not found' });
        }
        await claim.remove();
        res.status(200).json({ msg: 'Claim deleted' });
    } catch (error) {
        logger.error('Error deleting claim:', error);
        res.render('500', { message: 'Error deleting claim' });
    }
});

// Route for bulk updating claims, accessible by admin and manager
router.put('/bulk/update', ensureAuthenticated, ensureRoles(['admin', 'manager']), logActivity('Bulk updated claims'), async (req, res) => {
    const { claimIds, updateData } = req.body; // Extract claim IDs and update data from the request body

    logRequest(req, 'Bulk updating claims with IDs:', { claimIds, updateData });

    try {
        // Update multiple claims based on provided IDs and data
        const result = await Claim.updateMany({ _id: { $in: claimIds } }, updateData);
        logRequest(req, 'Claims updated:', { result });
        res.json({ msg: 'Claims updated', result }); // Respond with update result
        claimIds.forEach(id => cache.del(`claim_${id}`)); // Invalidate the cache for the updated claims
        //cache.del('/claims'); // Invalidate the cache for claims list
    } catch (err) {
        logRequest(req, 'Error bulk updating claims:', { error: err });
        res.render('500', { message: 'Error updating claims' });
    }
});

// Route for bulk exporting claims, accessible by admin and manager
router.post('/bulk/export', ensureAuthenticated, ensureRoles(['admin', 'manager']), logActivity('Bulk exported claims'), async (req, res) => {
    const { claimIds, format } = req.body; // Extract claim IDs and export format from the request body

    logRequest(req, 'Bulk exporting claims with IDs:', { claimIds, format });

    try {
        // Find claims based on provided IDs
        const claims = await Claim.find({ _id: { $in: claimIds } });

        if (format === 'csv') {
            logRequest(req, 'Exporting claims to CSV');
            res.csv(claims, true); // Export claims to CSV
        } else if (format === 'excel') {
            logRequest(req, 'Exporting claims to Excel');
            const workbook = new ExcelJS.Workbook();
            const worksheet = workbook.addWorksheet('Claims');
            worksheet.columns = [
                { header: 'MVA', key: 'mva', width: 10 },
                { header: 'Customer Name', key: 'customerName', width: 30 },
                { header: 'Description', key: 'description', width: 50 },
                { header: 'Status', key: 'status', width: 10 },
                { header: 'Date', key: 'date', width: 15 }
            ];
            claims.forEach(claim => {
                worksheet.addRow(claim);
            });
            res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            res.setHeader('Content-Disposition', 'attachment; filename=claims.xlsx');
            workbook.xlsx.write(res).then(() => res.end());
        } else if (format === 'pdf') {
            logRequest(req, 'Exporting claims to PDF');
            const doc = new PDFDocument();
            doc.pipe(res);
            doc.text('Claims Report', { align: 'center' });
            claims.forEach(claim => {
                doc.text(`MVA: ${claim.mva}`);
                doc.text(`Customer Name: ${claim.customerName}`);
                doc.text(`Description: ${claim.description}`);
                doc.text(`Status: ${claim.status}`);
                doc.text(`Date: ${new Date(claim.date).toLocaleDateString()}`);
                doc.moveDown();
            });
            doc.end();
        } else {
            logRequest(req, 'Invalid export format:', { format });
            res.status(400).json({ msg: 'Invalid format' });
        }
    } catch (err) {
        logRequest(req, 'Error exporting claims:', { error: err });
        res.status(500).json({ error: err.message }); // Handle errors
    }
});

// Route to view a specific claim by ID, with options to edit or delete, accessible by admin, manager, and employee
router.get('/:id', ensureAuthenticated, ensureRoles(['admin', 'manager', 'employee']), logActivity('Viewed claim details'), async (req, res) => {
    const claimId = req.params.id;
    logRequest(req, 'Fetching claim details with ID:', { claimId });

    try {
        const claim = await Claim.findById(claimId).populate('rentingLocation').exec(); // Populate rentingLocation
        if (!claim) {
            logRequest(req, `Claim with ID ${claimId} not found`, { level: 'error' });
            return res.status(404).render('404', { message: 'Claim not found' });
        }
        logRequest(req, 'Claim details fetched:', { claim });
        res.render('claim_view', { title: 'View Claim', claim });
    } catch (err) {
        logRequest(req, 'Error fetching claim details:', { error: err });
        res.status(500).render('500', { message: 'Internal Server Error' });
    }
});

// Route to add a new status
router.post('/status/add', ensureAuthenticated, ensureRoles(['admin', 'manager']), async (req, res) => {
    const { name } = req.body;

    try {
        const newStatus = new Status({ name });
        await newStatus.save();
        res.status(201).json({ message: 'Status added successfully' });
    } catch (error) {
        res.render('500', { message: 'Error adding status' });
    }
});

// Route to add a new damage type
router.post('/damage-type/add', ensureAuthenticated, ensureRoles(['admin', 'manager']), async (req, res) => {
    const { name } = req.body;

    try {
        const newDamageType = new DamageType({ name });
        await newDamageType.save();
        res.status(201).json({ message: 'Damage Type added successfully' });
    } catch (error) {
        res.render('500', { message: 'Error adding damage type' });
    }
});

// Route to add a new location
router.post('/location/add', ensureAuthenticated, ensureRoles(['admin', 'manager']), async (req, res) => {
    const { name } = req.body;

    try {
        const newLocation = new Location({ name });
        await newLocation.save();
        res.status(201).json({ message: 'Location added successfully' });
    } catch (error) {
        res.render('500', { message: 'Error adding location' });
    }
})

// Fetch all statuses
router.get('/statuses', ensureAuthenticated, ensureRoles(['admin']), async (req, res) => {
    logRequest(req, 'Statuses route accessed'); // Log route access
    try {
        const statuses = await Status.find(); // Fetch all statuses from the database
        logRequest(req, 'Statuses fetched', { statuses }); // Log fetched statuses
        res.json(statuses); // Return statuses as JSON
    } catch (err) {
        logRequest(req, 'Error fetching statuses', { error: err.message }); // Log error
        res.render('500', { message: 'Error fetching statuses' });
    }
});

// Route to remove a status
router.delete('/status/remove/:id', ensureAuthenticated, ensureRoles(['admin', 'manager']), async (req, res) => {
    const statusId = req.params.id;

    try {
        await Status.findByIdAndDelete(statusId);
        res.status(200).json({ message: 'Status removed successfully' });
    } catch (error) {
        res.render('500', { message: 'Error removing status' });
    }
});

// Route to remove a damage type
router.delete('/damage-type/remove/:id', ensureAuthenticated, ensureRoles(['admin', 'manager']), async (req, res) => {
    const damageTypeId = req.params.id;

    try {
        await DamageType.findByIdAndDelete(damageTypeId);
        res.status(200).json({ message: 'Damage Type removed successfully' });
    } catch (error) {
        res.render('500', { message: 'Error removing damage type' });
    }
});

// Fetch all damage types
router.get('/damage-types', ensureAuthenticated, ensureRoles(['admin']), async (req, res) => {
    logRequest(req, 'Damage Types route accessed'); // Log route access
    try {
        const damageTypes = await DamageType.find(); // Fetch all damage types from the database
        logRequest(req, 'Damage Types fetched', { damageTypes }); // Log fetched damage types
        res.json(damageTypes); // Return damage types as JSON
    } catch (err) {
        logRequest(req, 'Error fetching damage types', { error: err.message }); // Log error
        res.render('500', { message: 'Error fetching damage types' });
    }
});

// Route to add a new renting location
router.post('/location/add', ensureAuthenticated, ensureRoles(['admin', 'manager']), async (req, res) => {
    const { name } = req.body;
    try {
        const newLocation = new Location({ name });
        await newLocation.save();
        res.json({ message: 'Renting location added successfully' });
    } catch (error) {
        res.render('500', { message: 'Error adding location' });
    }
});

// Route to remove a renting location
router.delete('/location/remove/:id', ensureAuthenticated, ensureRoles(['admin', 'manager']), async (req, res) => {
    const locationId = req.params.id;
    try {
        await Location.findByIdAndDelete(locationId);
        res.json({ message: 'Renting location removed successfully' });
    } catch (error) {
        res.render('500', { message: 'Error removing location' });
    }
});

// Route to update max file sizes
router.post('/api/settings/file-sizes', ensureAuthenticated, ensureRole('admin'), async (req, res) => {
    try {
        // Update the MAX_FILE_SIZES constant
        Object.assign(global.MAX_FILE_SIZES, req.body);
        res.json({ message: 'File size limits updated successfully' });
    } catch (error) {
        res.render('500', { message: 'Error updating file sizes' });
    }
});

// Route to update max files per category
router.post('/api/settings/file-counts', ensureAuthenticated, ensureRole('admin'), async (req, res) => {
    try {
        // Update the MAX_FILES_PER_CATEGORY constant
        Object.assign(global.MAX_FILES_PER_CATEGORY, req.body);
        res.json({ message: 'File count limits updated successfully' });
    } catch (error) {
        res.render('500', { message: 'Error updating file counts' });
    }
});

// Route to update allowed file types
router.post('/api/settings/file-types', ensureAuthenticated, ensureRole('admin'), async (req, res) => {
    try {
        // Update the ALLOWED_FILE_TYPES constant
        Object.assign(global.ALLOWED_FILE_TYPES, req.body);
        res.json({ message: 'Allowed file types updated successfully' });
    } catch (error) {
        res.render('500', { message: 'Error updating file types' });
    }
});

// Add this route to handle the general settings page
router.get('/settings', ensureAuthenticated, ensureRole('admin'), async (req, res) => {
    try {
        // Fetch all locations, statuses, and damage types
        const [locations, statuses, damageTypes, dbSettings] = await Promise.all([
            Location.find().sort('name'),
            Status.find().sort('name'),
            DamageType.find().sort('name'),
            Settings.find()
        ]);

        // Convert settings array to object by type
        const settingsObj = dbSettings.reduce((acc, setting) => {
            acc[setting.type] = setting;
            return acc;
        }, {});

        res.render('general_settings', {
            locations,
            statuses,
            damageTypes,
            dbSettings: settingsObj
        });
    } catch (error) {
        console.error('Error fetching settings data:', error);
        res.render('500', { 
            message: 'Error loading settings page'
        });
    }
});

// Add these API routes for managing settings
router.post('/api/settings/:type', ensureAuthenticated, ensureRole('admin'), async (req, res) => {
    const { type } = req.params;
    const { name } = req.body;

    try {
        let result;
        switch (type.toLowerCase()) {
            case 'location':
                result = await Location.create({ name });
                break;
            case 'status':
                result = await Status.create({ name });
                break;
            case 'damagetype':
                result = await DamageType.create({ name });
                break;
            default:
                return res.status(400).json({ success: false, message: 'Invalid type' });
        }
        res.json({ success: true, data: result });
    } catch (error) {
        res.render('500', { message: 'Error adding setting' });
    }
});

router.put('/api/settings/:type/:id', ensureAuthenticated, ensureRole('admin'), async (req, res) => {
    const { type, id } = req.params;
    const { name } = req.body;

    try {
        let result;
        switch (type.toLowerCase()) {
            case 'location':
                result = await Location.findByIdAndUpdate(id, { name }, { new: true });
                break;
            case 'status':
                result = await Status.findByIdAndUpdate(id, { name }, { new: true });
                break;
            case 'damagetype':
                result = await DamageType.findByIdAndUpdate(id, { name }, { new: true });
                break;
            default:
                return res.status(400).json({ success: false, message: 'Invalid type' });
        }
        res.json({ success: true, data: result });
    } catch (error) {
        res.render('500', { message: 'Error updating setting' });
    }
});

router.delete('/api/settings/:type/:id', ensureAuthenticated, ensureRole('admin'), async (req, res) => {
    const { type, id } = req.params;

    try {
        let result;
        switch (type.toLowerCase()) {
            case 'location':
                result = await Location.findByIdAndDelete(id);
                break;
            case 'status':
                result = await Status.findByIdAndDelete(id);
                break;
            case 'damagetype':
                result = await DamageType.findByIdAndDelete(id);
                break;
            default:
                return res.status(400).json({ success: false, message: 'Invalid type' });
        }
        res.json({ success: true, data: result });
    } catch (error) {
        res.render('500', { message: 'Error removing setting' });
    }
});

// Route to update invoice total
router.put('/:id/invoice-total', ensureAuthenticated, ensureRoles(['admin', 'manager']), async (req, res) => {
    const claimId = req.params.id;
    const { fileName, total } = req.body;

    try {
        // Find the claim
        const claim = await Claim.findById(claimId);
        if (!claim) {
            console.error(`Claim not found with ID: ${claimId}`);
            return res.status(404).json({ 
                success: false, 
                message: 'Claim not found' 
            });
        }

        // Find and update the specific invoice total
        const invoiceIndex = claim.invoiceTotals.findIndex(inv => inv.fileName === fileName);
        if (invoiceIndex !== -1) {
            // Log the update
            console.log(`Updating invoice total for ${fileName}:`, {
                oldTotal: claim.invoiceTotals[invoiceIndex].total,
                newTotal: total
            });

            // Update the total
            claim.invoiceTotals[invoiceIndex].total = parseFloat(total);
            await claim.save();

            // Return success with updated data
            res.json({ 
                success: true,
                data: {
                    invoiceTotal: claim.invoiceTotals[invoiceIndex],
                    adminFee: calculateAdminFee(claim.invoiceTotals)
                }
            });
        } else {
            console.error(`Invoice not found: ${fileName} in claim ${claimId}`);
            res.status(404).json({ 
                success: false, 
                message: 'Invoice not found' 
            });
        }
    } catch (error) {
        console.error('Error updating invoice total:', error);
        res.render('500', { message: 'Error updating invoice total' });
    }
});

// Helper function to calculate admin fee
function calculateAdminFee(invoiceTotals) {
    const totalInvoices = invoiceTotals.reduce((sum, invoice) => sum + (invoice.total || 0), 0);
    let adminFee = 0;
    
    if (totalInvoices >= 100 &amp;&amp; totalInvoices &lt; 500) {
        adminFee = 50;
    } else if (totalInvoices >= 500 &amp;&amp; totalInvoices &lt; 1500) {
        adminFee = 100;
    } else if (totalInvoices >= 1500) {
        adminFee = 150;
    }
    
    return adminFee;
}

module.exports = router; // Export the router</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-routes_api.html">routes/api</a></li><li><a href="module-routes_auditLogs.html">routes/auditLogs</a></li><li><a href="module-routes_customers.html">routes/customers</a></li><li><a href="module-routes_export.html">routes/export</a></li><li><a href="module-routes_import.html">routes/import</a></li><li><a href="module-routes_index.html">routes/index</a></li><li><a href="module-routes_reports.html">routes/reports</a></li><li><a href="module-routes_users.html">routes/users</a></li></ul><h3>Global</h3><ul><li><a href="global.html#express">express</a></li><li><a href="global.html#filterSensitiveData">filterSensitiveData</a></li><li><a href="global.html#logActivity">logActivity</a></li><li><a href="global.html#logRequest">logRequest</a></li><li><a href="global.html#replaceVariables">replaceVariables</a></li><li><a href="global.html#sensitiveFields">sensitiveFields</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Jan 07 2025 04:54:18 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
